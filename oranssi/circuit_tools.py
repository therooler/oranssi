import pennylane as qml
import numpy as np
from typing import List, Tuple
import copy


def retraction(circuit, observable, wires, eta):
    circuit()
    observable(-np.pi / 2, wires=wires)
    qml.adjoint(circuit)
    qml.PhaseShift(-eta / 2, wires=0)
    qml.X(wires=0)
    circuit()
    observable(np.pi / 2, wires=wires)
    observable(np.pi / 2, wires=wires)
    qml.adjoint(circuit)
    qml.PhaseShift(eta / 2, wires=0)
    qml.X(wires=0)
    circuit()
    observable(-np.pi / 2, wires=wires)

    new_circuit = 0


def param_shift_comm(rho: np.ndarray, gate) -> np.ndarray:
    """
    Parameter shift on operator space that calculates [rho, O]

    Args:
        rho: Density matrix representing the state.
        gate: Unitary generated by a function lambda t: exp(-t/2 O), where O is the observable that we want to measure.

    Returns:
        Operator corresponding to the commutator [rho, O]
    """
    return gate(np.pi / 2) @ (rho @ gate(np.pi / 2).conj().T) - gate(-np.pi / 2) @ (rho @ gate(-np.pi / 2).conj().T)


def get_full_operator(op: np.ndarray, wires: Tuple[int,...], nqubits: int) -> np.ndarray:
    """
    Takes a local operator `op` acting on `wires` and promotes it to an operatr on the full unitary space
    C^{2^n x 2^n}.

    Args:
        op: numpy array correspondig to the local unitary.
        wires: Tuple of integers corresponding to the qubits that the operator is acting on.
        nqubits: The number of qubits in the system.

    Returns:
        Numpy array of size 2^n x 2^n corresponding to the full unitary.
    """
    assert max(wires) < nqubits, f'Operator is acting on qubit {max(wires)}, but nqubits is {nqubits}'
    final_operator = np.eye(2 ** nqubits, 2 ** nqubits, dtype=complex).reshape([2] * 2 * nqubits)
    op = op.reshape([2] * 2 * len(wires))
    einsum_indices_operator = list(range(2 * len(wires)))
    einsum_indices_final_operator = list(range(2 * len(wires), 2 * nqubits + 2 * len(wires)))
    for i, w in enumerate(wires):
        einsum_indices_final_operator[w] = einsum_indices_operator[i]
    einsum_indices_operator_out = copy.copy(einsum_indices_final_operator)
    for i, w in enumerate(wires):
        einsum_indices_operator_out[w] = einsum_indices_operator[i + len(wires)]

    final_operator = np.einsum(final_operator, einsum_indices_final_operator,
                               op, einsum_indices_operator,
                               einsum_indices_operator_out)
    return final_operator.reshape((2 ** nqubits, 2 ** nqubits))


def circuit_observable_from_unitary(**kwargs):
    """
    Take a unitary as input and construct the corresponding operator on the circuit.
    Then, measure a single observable.

    Args:
        **kwargs: MUST contain keys 'unitary' and 'observable', with a 2^n x 2^n numpy array and PennyLane observable
        as values.

    Returns:
        Pennylane Expectation value.
    """
    assert all(k in kwargs.keys() for k in ['unitary', 'observable']), \
        "kwargs must MUST contain keys `unitary` and `observable`," \
        " with a 2^n x 2^n numpy array and PennyLane observable as values" \
        f", received {list(kwargs.keys())}"
    unitary = kwargs.pop('unitary')
    observable = kwargs.get('observable')
    nqubits = int(np.log2(unitary.shape[0]))
    qml.QubitUnitary(unitary, wires=list(range(nqubits)))
    return qml.expval(observable)


def circuit_state_from_unitary(**kwargs):
    """
    Take a unitary as input and construct the corresponding operator on the circuit.
    Then, return the full state.

    Args:
        **kwargs: MUST contain key 'unitary' , with a 2^n x 2^n numpy array.

    Returns:
        Pennylane State.
    """
    assert all(k in kwargs.keys() for k in ['unitary']), \
        "kwargs must MUST contain key `unitary`," \
        " with a 2^n x 2^n numpy array" \
        f", received {list(kwargs.keys())}"
    unitary = kwargs.pop('unitary')
    nqubits = int(np.log2(unitary.shape[0]))
    qml.QubitUnitary(unitary, wires=list(range(nqubits)))
    return qml.state()


def get_ops_from_qnode(circuit, params: List, device: qml.Device) -> Tuple[List, List[Tuple[int, ...]]]:
    """
    Construct the PennyLane circuit and extract the gates in matrix form.

    Args:
        circuit: function with signature (params, **kwargs) that returns a PennyLane state or observable.
        params: Circuit parameters as list.
        device: PennyLane device.

    Returns:
        List of numpy array and list of wires.
    """
    qnode = qml.QNode(circuit, device)
    qnode.construct([params], {})
    circuit_as_numpy_ops = []
    circuit_as_numpy_wires = []
    for op in qnode.qtape._ops:
        circuit_as_numpy_ops.append(op.matrix)
        circuit_as_numpy_wires.append(op.wires.labels)
    return circuit_as_numpy_ops, circuit_as_numpy_wires
