import pennylane as qml
import numpy as np
from typing import List, Tuple
import copy
from oranssi.utils import get_su_n_operators
import networkx as nx
from oranssi.edge_coloring import applyHeuristic


def param_shift_comm(rho: np.ndarray, gate) -> np.ndarray:
    """
    Parameter shift on operator space that calculates [rho, O]

    Args:
        rho: Density matrix representing the state.
        gate: Unitary generated by a function lambda t: exp(-t/2 O), where O is the observable that we want to measure.

    Returns:
        Operator corresponding to the commutator [rho, O]
    """
    return gate(np.pi / 2) @ (rho @ gate(np.pi / 2).conj().T) - gate(-np.pi / 2) @ (
            rho @ gate(-np.pi / 2).conj().T)


def get_full_operator(op: np.ndarray, wires: Tuple[int, ...], nqubits: int) -> np.ndarray:
    """
    Takes a local operator `op` acting on `wires` and promotes it to an operator on the full unitary space
    C^{2^n x 2^n}.

    Args:
        op: numpy array correspondig to the local unitary.
        wires: Tuple of integers corresponding to the qubits that the operator is acting on.
        nqubits: The number of qubits in the system.

    Returns:
        Numpy array of size 2^n x 2^n corresponding to the full unitary.
    """
    assert max(
        wires) < nqubits, f'Operator is acting on qubit {max(wires)}, but nqubits is {nqubits}'
    opsize = int(np.log2(op.shape[0]))
    assert opsize == len(
        wires), f'Operator is shape {op.shape} acting on {opsize} qubits, but wires = {wires}'
    final_operator = np.eye(2 ** nqubits, 2 ** nqubits, dtype=complex).reshape([2] * 2 * nqubits)
    op = op.reshape([2] * 2 * len(wires))
    einsum_indices_operator = list(range(2 * len(wires)))
    einsum_indices_final_operator = list(range(2 * len(wires), 2 * nqubits + 2 * len(wires)))

    for i, w in enumerate(wires):
        einsum_indices_final_operator[w] = einsum_indices_operator[i + len(wires)]
    einsum_indices_operator_out = copy.copy(einsum_indices_final_operator)
    for i, w in enumerate(wires):
        einsum_indices_operator_out[w] = einsum_indices_operator[i]
    final_operator = np.einsum(op, einsum_indices_operator,
                               final_operator, einsum_indices_final_operator,
                               einsum_indices_operator_out)
    return final_operator.reshape((2 ** nqubits, 2 ** nqubits))


def circuit_observable_from_unitary(**kwargs):
    """
    Take a unitary as input and construct the corresponding operator on the circuit.
    Then, measure a single observable.

    Args:
        **kwargs: MUST contain keys 'unitary' and 'observable', with a 2^n x 2^n numpy array and PennyLane observable
        as values.

    Returns:
        Pennylane Expectation value.
    """
    assert all(k in kwargs.keys() for k in ['unitary', 'observable']), \
        "kwargs must MUST contain keys `unitary` and `observable`," \
        " with a 2^n x 2^n numpy array and PennyLane observable as values" \
        f", received {list(kwargs.keys())}"
    unitary = kwargs.pop('unitary')
    observable = kwargs.get('observable')
    nqubits = int(np.log2(unitary.shape[0]))
    qml.QubitUnitary(unitary, wires=list(range(nqubits)))
    return qml.expval(observable)


def circuit_state_from_unitary(**kwargs):
    """
    Take a unitary as input and construct the corresponding operator on the circuit.
    Then, return the full state.

    Args:
        **kwargs: MUST contain key 'unitary' , with a 2^n x 2^n numpy array.

    Returns:
        Pennylane State.
    """
    assert all(k in kwargs.keys() for k in ['unitary']), \
        "kwargs must MUST contain key `unitary`," \
        " with a 2^n x 2^n numpy array" \
        f", received {list(kwargs.keys())}"
    unitary = kwargs.pop('unitary')
    nqubits = int(np.log2(unitary.shape[0]))
    qml.QubitUnitary(unitary, wires=list(range(nqubits)))
    return qml.state()


def get_ops_from_qnode(circuit, params: List, device: qml.Device) -> Tuple[
    List, List[Tuple[int, ...]]]:
    """
    Construct the PennyLane circuit and extract the gates in matrix form.

    Args:
        circuit: function with signature (params, **kwargs) that returns a PennyLane state or observable.
        params: Circuit parameters as list.
        device: PennyLane device.

    Returns:
        List of numpy array and list of wires.
    """
    qnode = qml.QNode(circuit, device)
    qnode.construct([params], {})
    circuit_as_numpy_ops = []
    circuit_as_numpy_wires = []
    for op in qnode.qtape._ops:
        circuit_as_numpy_ops.append(op.matrix)
        circuit_as_numpy_wires.append(op.wires.labels)
    return circuit_as_numpy_ops, circuit_as_numpy_wires


def get_hamiltonian_matrix(nqubits, observables, coeffs=None):
    """
    Return the matrix constructed from a list of PennyLane observables

    Args:
        nqubits: Integer number of qubits.
        observables: List of Pennylane observables.
        coeffs: List of float coefficients in front of the operators in the Hamiltonian

    Returns:
        Matrix corresponding to the Hamiltonian

    """
    hamiltonian = np.zeros((2 ** nqubits, 2 ** nqubits), dtype=complex)
    if coeffs is None:
        coeffs = np.ones(len(observables))
    for i, o in enumerate(observables):
        hamiltonian += coeffs[i] * get_full_operator(o.matrix, o.wires, nqubits)
    return hamiltonian


def get_all_su_n_directions(unitary, observables, device):
    """
    Get all SU(2^N) directions in a dictionary where the keys are Pauli words

    Args:
        unitary: Matrix corresponding to a unitary matrix
        observables: List of PennyLane observables.
        device: PennyLane device.

    Returns:
        Dictionary containing the directions and corresponding SU(2^N) directions.

    """
    nqubits = len(device.wires)
    observables_full = [get_full_operator(obs.matrix, obs.wires, nqubits) for obs in
                        observables]
    paulis, names = get_su_n_operators(2 ** nqubits, identity=True, return_names=True)
    circuit_state_from_unitary_qnode = qml.QNode(circuit_state_from_unitary, device)
    phi = circuit_state_from_unitary_qnode(unitary=unitary)[:, np.newaxis]
    omegas = {}
    for p, n in zip(paulis, names):
        omegas[n] = 0
        for obs in observables_full:
            omegas[n] += float((phi.conj().T @ (p @ obs - obs @ p) @ phi).imag) / 2**nqubits
    return omegas


def get_commuting_set(edge_list):
    """
    Find a set of non-overlapping bond given a set of edges

    Args:
        edge_list: List of edges.

    Returns:
        List of colored edges.
    """
    unrolled_edges = [item for sublist in edge_list for item in sublist]
    if len(unrolled_edges) == len(set(unrolled_edges)):
        return edge_list
    else:
        g = nx.from_edgelist(edge_list)
        applyHeuristic(g, 2, 50, 50)
        edge_coloring = [e for e in g.edges() if g[e[0]][e[1]]['color'] == 0]
        return edge_coloring
